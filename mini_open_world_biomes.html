<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Mini Open World ‚Äî Biomes (Genshin‚Äëstyle Slice)</title>
<meta name="theme-color" content="#0a0f1a"/>
<style>
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:#0a0f1a;color:#e8f0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  canvas{display:block}
  /* HUD */
  #hud{position:fixed;left:.75rem;top:.75rem;display:grid;gap:.4rem;z-index:5}
  .bar{width:220px;height:14px;background:#1b2333;border:1px solid #2d3850;border-radius:10px;overflow:hidden}
  .hp{height:100%;background:linear-gradient(90deg,#ff4757,#ff7f50)}
  .st{height:100%;background:linear-gradient(90deg,#2ed573,#7bed9f)}
  #coins{font-weight:700;opacity:.95}
  #badge{position:fixed;right:.75rem;top:.75rem;background:#0008;border:1px solid #2d3850;padding:.3rem .6rem;border-radius:.5rem;font-size:.9rem;opacity:.9;z-index:5}
  /* Touch controls */
  #touch{position:fixed;inset:0;pointer-events:none;z-index:6}
  .stick{position:absolute;left:1rem;bottom:1rem;width:140px;height:140px;border-radius:50%;background:#0006;border:1px solid #334;padding:24px;pointer-events:auto;touch-action:none}
  .knob{width:92px;height:92px;border-radius:50%;background:#222d3d;border:1px solid #3a4a66}
  .btns{position:absolute;right:1rem;bottom:1rem;display:grid;gap:.6rem;pointer-events:auto}
  .btn{min-width:72px;min-height:72px;border-radius:16px;border:1px solid #3a4a66;background:#1a2333;color:#fff;font-weight:800;box-shadow:0 6px 20px #0007;touch-action:none}
  .btn:active{transform:scale(.97)}
  .small{min-width:64px;min-height:64px}
  /* Top menu */
  #menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(1000px 600px at 70% 20%,#223,#000),linear-gradient(#05070d,#02040a);z-index:9}
  #menu .panel{width:min(92vw,560px);background:#0e1422;border:1px solid #1b2740;border-radius:14px;padding:16px 18px;box-shadow:0 12px 50px #000c}
  #menu h1{margin:.2rem 0 .5rem 0;font-size:1.4rem}
  #menu label{display:block;margin:.6rem 0 .2rem 0;opacity:.9}
  #menu select,#menu input[type=range]{width:100%;padding:10px;border-radius:10px;border:1px solid #283554;background:#0f182a;color:#fff}
  #start{margin-top:10px;width:100%;background:#1248ff;border:1px solid #2b5bff;color:#fff;padding:12px;border-radius:12px;font-weight:900}
  #hint{position:fixed;left:50%;transform:translateX(-50%);bottom:.8rem;background:#0008;border:1px solid #2d3850;padding:.4rem .6rem;border-radius:.5rem;font-size:.9rem;opacity:.9;z-index:4}
</style>
</head>
<body>
<div id="menu">
  <div class="panel">
    <h1>üåç Mini Open World ‚Äî Multi‚ÄëBiomes</h1>
    <div style="opacity:.85">‡¶°‡ßá‡¶ú‡¶æ‡¶∞‡ßç‡¶ü/‡¶ó‡ßç‡¶∞‡¶æ‡¶∏/‡¶´‡¶∞‡ßá‡¶∏‡ßç‡¶ü/‡¶∏‡ßç‡¶®‡ßã + ‡¶¨‡¶ø‡¶ö ‡¶ü‡¶ø‡¶®‡ßç‡¶ü ‚Ä¢ 3D ‡¶•‡¶æ‡¶∞‡ßç‡¶°‚Äë‡¶™‡¶æ‡¶∞‡ßç‡¶∏‡¶®, ‡¶ú‡¶æ‡¶Æ‡ßç‡¶™/‡¶∏‡ßç‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü/‡¶ó‡ßç‡¶≤‡¶æ‡¶á‡¶°, ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶ï, ‡¶è‡¶®‡ßá‡¶Æ‡¶ø AI‡•§</div>
    <label>‡¶ï‡ßã‡ßü‡¶æ‡¶≤‡¶ø‡¶ü‡¶ø</label>
    <select id="quality">
      <option value="low">Low (‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤)</option>
      <option value="med" selected>Medium</option>
      <option value="high">High</option>
    </select>
    <label>‡¶Æ‡ßç‡¶Ø‡¶æ‡¶™ ‡¶∏‡¶ø‡¶°</label>
    <select id="seed">
      <option>azure</option><option selected>ember</option><option>jade</option><option>lumen</option><option>terra</option>
    </select>
    <label>‡¶∏‡¶Æ‡ßü</label>
    <input id="tod" type="range" min="0" max="1" step="0.01" value="0.35"/>
    <button id="start">‚ñ∂Ô∏è Start</button>
  </div>
</div>

<div id="hud">
  <div class="bar"><div id="hp" class="hp" style="width:100%"></div></div>
  <div class="bar"><div id="st" class="st" style="width:100%"></div></div>
  <div id="coins">üí´ 0</div>
</div>
<div id="badge">Biomes: Desert ‚Ä¢ Grass ‚Ä¢ Forest ‚Ä¢ Snow</div>

<div id="touch">
  <div id="stick" class="stick"><div id="knob" class="knob"></div></div>
  <div class="btns">
    <button id="attack" class="btn small">‚öîÔ∏è</button>
    <button id="jump" class="btn small">ü¶ò</button>
    <button id="sprint" class="btn">üèÉ</button>
    <button id="glide" class="btn">ü™Ç</button>
  </div>
</div>

<div id="hint">‡¶ï‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶∞‡¶æ ‡¶ò‡ßã‡¶∞‡¶æ‡¶§‡ßá ‡¶∏‡ßã‡ßü‡¶æ‡¶á‡¶™ ‚Ä¢ Move: ‡¶ú‡¶Ø‡¶º‡¶∏‡ßç‡¶ü‡¶ø‡¶ï/WASD ‚Ä¢ Jump: Space ‚Ä¢ Sprint: Shift ‚Ä¢ Glide/Attack ‡¶¨‡ßã‡¶§‡¶æ‡¶Æ</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
(()=>{
  'use strict';

  // ===== Helpers =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // ===== Input =====
  const keys={w:0,a:0,s:0,d:0,space:0,shift:0,mouseDown:0};
  let yaw=0,pitch=-0.3, lookDZ=0.15, gliding=false;

  // Touch joystick
  const stick=document.getElementById('stick'), knob=document.getElementById('knob');
  const joy={x:0,y:0,active:false, cx:0, cy:0};
  function onStickStart(e){ joy.active=true; const r=stick.getBoundingClientRect(); joy.cx=r.left+r.width/2; joy.cy=r.top+r.height/2; onStickMove(e); }
  function onStickMove(e){ if(!joy.active) return; const t=(e.touches?e.touches[0]:e);
    const dx=t.clientX-joy.cx, dy=t.clientY-joy.cy; const rad=56; const len=Math.hypot(dx,dy), f=len?Math.min(1,len/rad):0;
    joy.x=(dx/(len||1))*f; joy.y=(dy/(len||1))*f; knob.style.transform=`translate(${joy.x*rad}px,${joy.y*rad}px)`; }
  function onStickEnd(){ joy.active=false; joy.x=joy.y=0; knob.style.transform='translate(0,0)'; }
  stick.addEventListener('touchstart',e=>{e.preventDefault();onStickStart(e)},{passive:false});
  stick.addEventListener('touchmove',e=>{e.preventDefault();onStickMove(e)},{passive:false});
  stick.addEventListener('touchend',e=>{e.preventDefault();onStickEnd()},{passive:false});
  // Buttons
  const btnAttack=document.getElementById('attack'), btnJump=document.getElementById('jump');
  const btnSprint=document.getElementById('sprint'), btnGlide=document.getElementById('glide');
  btnAttack.addEventListener('touchstart',e=>{e.preventDefault();keys.mouseDown=1;},{passive:false});
  btnAttack.addEventListener('touchend',e=>{e.preventDefault();keys.mouseDown=0;},{passive:false});
  btnJump.addEventListener('touchstart',e=>{e.preventDefault();keys.space=1;},{passive:false});
  btnJump.addEventListener('touchend',e=>{e.preventDefault();keys.space=0;},{passive:false});
  btnSprint.addEventListener('touchstart',e=>{e.preventDefault();keys.shift=1;},{passive:false});
  btnSprint.addEventListener('touchend',e=>{e.preventDefault();keys.shift=0;},{passive:false});
  btnGlide.addEventListener('touchstart',e=>{e.preventDefault();gliding=true;},{passive:false});
  btnGlide.addEventListener('touchend',e=>{e.preventDefault();gliding=false;},{passive:false});

  window.addEventListener('keydown',e=>{
    if('wWArrowUp'.includes(e.key)) keys.w=1;
    if('sSArrowDown'.includes(e.key)) keys.s=1;
    if('aAArrowLeft'.includes(e.key)) keys.a=1;
    if('dDArrowRight'.includes(e.key)) keys.d=1;
    if(e.key===' ') keys.space=1;
    if(e.key==='Shift') keys.shift=1;
  });
  window.addEventListener('keyup',e=>{
    if('wWArrowUp'.includes(e.key)) keys.w=0;
    if('sSArrowDown'.includes(e.key)) keys.s=0;
    if('aAArrowLeft'.includes(e.key)) keys.a=0;
    if('dDArrowRight'.includes(e.key)) keys.d=0;
    if(e.key===' ') keys.space=0;
    if(e.key==='Shift') keys.shift=0;
  });
  window.addEventListener('mousedown',()=>keys.mouseDown=1);
  window.addEventListener('mouseup',()=>keys.mouseDown=0);

  // Touch camera drag
  let lastDrag=null;
  window.addEventListener('touchstart',e=>{ if(e.target.closest('#touch')) return; lastDrag=e.touches[0]; }, {passive:true});
  window.addEventListener('touchmove',e=>{
    if(!lastDrag) return;
    const t=e.touches[0]; const dx=(t.clientX-lastDrag.clientX)/160; const dy=(t.clientY-lastDrag.clientY)/160;
    if(Math.hypot(dx,dy)>lookDZ){ yaw-=dx; pitch=clamp(pitch-dy, -1.2, 0.6); }
    lastDrag=t;
  }, {passive:true});
  window.addEventListener('touchend',()=>{ lastDrag=null; }, {passive:true});

  // ===== THREE setup =====
  const renderer=new THREE.WebGLRenderer({antialias:true});
  document.body.appendChild(renderer.domElement);
  const scene=new THREE.Scene();
  const camera=new THREE.PerspectiveCamera(60,1,0.1,3000);
  const ambient=new THREE.HemisphereLight(0x88aaff,0x223344,0.65); scene.add(ambient);
  const sun=new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(100,140,60); scene.add(sun);

  // Sky / time of day
  const tod=document.getElementById('tod');
  function updateSky(){
    const t=parseFloat(tod.value);
    const top=new THREE.Color().lerpColors(new THREE.Color('#0b1a3a'), new THREE.Color('#87b7ff'), t);
    renderer.setClearColor(top, 1);
    ambient.color.copy(top.clone().multiplyScalar(0.9));
    sun.color.setHSL(0.12+0.08*t, 0.6, 0.7+0.2*t);
    sun.position.set(200*Math.cos(t*Math.PI*2), 200*(0.2+0.8*t), 200*Math.sin(t*Math.PI*2));
  }

  function resize(){
    const dpr=Math.min(2, window.devicePixelRatio||1);
    const w=innerWidth, h=innerHeight;
    renderer.setSize(w,h,false); renderer.setPixelRatio(dpr);
    camera.aspect=w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  // ===== Terrain + Biomes =====
  // noise
  function hash(x,y){ let s=Math.sin(x*127.1+y*311.7)*43758.5453123; return s-Math.floor(s); }
  function noise2(x,y){ const xi=Math.floor(x), yi=Math.floor(y); const xf=x-xi, yf=y-yi;
    const tl=hash(xi,yi), tr=hash(xi+1,yi), bl=hash(xi,yi+1), br=hash(xi+1,yi+1);
    const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf); return lerp(lerp(tl,tr,u), lerp(bl,br,u), v); }
  function fbm(x,y,oct=5,base=0.007,a0=0.8){ let f=0,a=a0,s=base; for(let i=0;i<oct;i++){ f+=noise2(x*s,y*s)*a; a*=0.5; s*=2.0; } return f; }

  let terrain, terrainGeom, terrainSize=1400, seg=150, heightScale=70, seedMul=1.0;
  let biomeAt; // function (x,z)->string

  function makeTerrain(seedStr, quality){
    seg = (quality==='low'? 96 : quality==='med'? 140 : 200);
    heightScale = (quality==='low'? 50 : quality==='med'? 70 : 90);
    seedMul = (seedStr==='ember'? 1.3 : seedStr==='jade'? 2.1 : seedStr==='lumen'? 0.9 : seedStr==='terra'? 1.7 : 1.0);

    if(terrain){ scene.remove(terrain); terrain.geometry.dispose(); terrain.material.dispose(); }
    terrainGeom=new THREE.PlaneGeometry(terrainSize, terrainSize, seg, seg);

    const pos=terrainGeom.attributes.position;
    const colors=new Float32Array((seg+1)*(seg+1)*3);
    const c=new THREE.Color();

    // biome util
    const mScale=0.004*seedMul, tScale=0.003*seedMul;
    biomeAt = (x,z)=>{
      const h = fbm(x*seedMul, z*seedMul, 5, 0.006, 0.8) * heightScale; // altitude
      const hN = clamp(h/heightScale, 0, 1);
      const temp = clamp(1.0 - hN + fbm(x*seedMul+1000, z*seedMul-1000, 3, tScale, 0.7)*0.25, 0, 1);
      const moist = clamp(fbm(x*seedMul-5000, z*seedMul+3000, 4, mScale, 0.9), 0, 1);
      if (h < 6) return 'beach';
      if (temp<0.35) return 'snow';
      if (temp>0.65 && moist<0.4) return 'desert';
      if (moist>0.6) return 'forest';
      return 'grass';
    };

    // set heights + vertex colors
    for(let i=0;i<pos.count;i++){
      const x=pos.getX(i), z=pos.getY(i);
      const h = fbm(x*seedMul, z*seedMul, 5, 0.006, 0.8) * heightScale;
      pos.setZ(i, h);
      const b = biomeAt(x,z);
      if(b==='desert') c.set('#d8c384');
      else if(b==='forest') c.set('#2e7d32');
      else if(b==='snow') c.set('#f0f6ff');
      else if(b==='beach') c.set('#e8d7a8');
      else c.set('#6fbf73'); // grass
      colors[i*3+0]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
    }
    pos.needsUpdate=true; terrainGeom.setAttribute('color', new THREE.BufferAttribute(colors,3));
    terrainGeom.computeVertexNormals();
    const mat=new THREE.MeshStandardMaterial({vertexColors:true, roughness:0.95, metalness:0.0});
    terrain=new THREE.Mesh(terrainGeom, mat); terrain.rotation.x=-Math.PI/2; scene.add(terrain);

    buildProps(seedStr);
  }

  function sampleHeight(x,z){
    const grid=seg, half=terrainSize/2, step=terrainSize/grid;
    const fx=(x+half)/step, fz=(z+half)/step;
    const ix=clamp(Math.floor(fx),0,grid), iz=clamp(Math.floor(fz),0,grid);
    const idx=iz*(grid+1)+ix;
    return terrainGeom.attributes.position.getZ(idx);
  }
  function slopeAt(x,z){
    const s=1.5;
    const h=sampleHeight(x,z);
    const hx=sampleHeight(x+s,z)-h;
    const hz=sampleHeight(x,z+s)-h;
    return Math.sqrt(hx*hx+hz*hz);
  }

  // ===== Props per biome (instanced) =====
  let propGroup;
  function buildProps(seedStr){
    if(propGroup){ scene.remove(propGroup); propGroup.traverse(o=>{ if(o.isInstancedMesh){ o.geometry.dispose(); o.material.dispose(); } }); }
    propGroup=new THREE.Group(); scene.add(propGroup);

    const rngSeed = (s)=>{ let h=0; for(let i=0;i<s.length;i++) h=(h*131+s.charCodeAt(i))>>>0; return ()=> (h = (1103515245*h + 12345)>>>0, (h&0xffff)/0xffff); };
    const rnd=rngSeed(seedStr+'props');

    // Forest trees (cone + cylinder)
    const trunkGeo=new THREE.CylinderGeometry(0.6, 0.8, 5, 6);
    const crownGeo=new THREE.ConeGeometry(3.0, 6.0, 8);
    const trunkMat=new THREE.MeshStandardMaterial({color:0x6b4f2a, roughness:1.0});
    const leafMat =new THREE.MeshStandardMaterial({color:0x2f7a32, roughness:0.9});
    const trees = new THREE.InstancedMesh(crownGeo, leafMat, 200);
    const trunks= new THREE.InstancedMesh(trunkGeo, trunkMat, 200);
    let ti=0;
    for(let i=0;i<200;i++){
      const x=(rnd()-0.5)*terrainSize*0.85, z=(rnd()-0.5)*terrainSize*0.85;
      const b=biomeAt(x,z); if(b!=='forest') continue;
      if (slopeAt(x,z)>1.6) continue;
      const y=sampleHeight(x,z);
      const m=new THREE.Matrix4().compose(new THREE.Vector3(x,y+6,z), new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),(rnd()*Math.PI*2)), new THREE.Vector3(1,1,1));
      trees.setMatrixAt(ti, m);
      const mt=new THREE.Matrix4().compose(new THREE.Vector3(x,y+2.2,z), new THREE.Quaternion(), new THREE.Vector3(1,1,1));
      trunks.setMatrixAt(ti, mt);
      ti++;
    }
    trees.instanceMatrix.needsUpdate=true; trunks.count=ti; trees.count=ti; propGroup.add(trunks); propGroup.add(trees);

    // Desert cacti
    const cactusGeo=new THREE.CylinderGeometry(0.8,0.9,6,6);
    const cactusMat=new THREE.MeshStandardMaterial({color:0x3ca370, roughness:0.9});
    const cacti=new THREE.InstancedMesh(cactusGeo, cactusMat, 140);
    let ci=0;
    for(let i=0;i<140;i++){
      const x=(rnd()-0.5)*terrainSize*0.85, z=(rnd()-0.5)*terrainSize*0.85;
      const b=biomeAt(x,z); if(b!=='desert') continue;
      if (slopeAt(x,z)>1.4) continue;
      const y=sampleHeight(x,z);
      const s=0.8+rnd()*0.7;
      const m=new THREE.Matrix4().compose(new THREE.Vector3(x,y+3*s,z), new THREE.Quaternion(), new THREE.Vector3(s,s,s));
      cacti.setMatrixAt(ci++, m);
    }
    cacti.count=ci; cacti.instanceMatrix.needsUpdate=true; propGroup.add(cacti);

    // Snow rocks
    const rockGeo=new THREE.IcosahedronGeometry(2.2,0);
    const rockMat=new THREE.MeshStandardMaterial({color:0xbfc7d9, roughness:0.9});
    const rocks=new THREE.InstancedMesh(rockGeo, rockMat, 160);
    let ri=0;
    for(let i=0;i<200;i++){
      const x=(rnd()-0.5)*terrainSize*0.85, z=(rnd()-0.5)*terrainSize*0.85;
      const b=biomeAt(x,z); if(b!=='snow') continue;
      if (slopeAt(x,z)>1.8) continue;
      const y=sampleHeight(x,z);
      const s=0.8+rnd()*1.1;
      const q=new THREE.Quaternion().setFromEuler(new THREE.Euler(rnd()*0.5, rnd()*Math.PI*2, rnd()*0.5));
      const m=new THREE.Matrix4().compose(new THREE.Vector3(x,y+2*s,z), q, new THREE.Vector3(s,s,s));
      rocks.setMatrixAt(ri++, m);
    }
    rocks.count=ri; rocks.instanceMatrix.needsUpdate=true; propGroup.add(rocks);
  }

  // ===== Player / Enemies / Collectibles =====
  const player={pos:new THREE.Vector3(0,40,0), vel:new THREE.Vector3(), yaw:0, onGround:false, hp:100, stamina:100};
  const playerMesh = new THREE.Mesh(new THREE.CapsuleGeometry(2,5,8,14), new THREE.MeshStandardMaterial({color:0xff6666, roughness:0.6, metalness:0.1}));
  scene.add(playerMesh);

  const enemyMat=new THREE.MeshStandardMaterial({color:0x66aaff, roughness:0.6, metalness:0.05});
  const enemies=[];
  function spawnEnemy(x,z){
    const m=new THREE.Mesh(new THREE.SphereGeometry(3,22,16), enemyMat.clone());
    m.position.set(x, sampleHeight(x,z)+3, z);
    m.userData={hp:30, t:0};
    scene.add(m); enemies.push(m);
  }
  const collectibles=[]; let coinCount=0; const coinsEl=document.getElementById('coins');
  function spawnCoins(n=24){
    for(let i=0;i<n;i++){
      const x=(Math.random()-0.5)*terrainSize*0.8, z=(Math.random()-0.5)*terrainSize*0.8;
      const y=sampleHeight(x,z)+2;
      const geo=new THREE.SphereGeometry(1.2,14,12);
      const mat=new THREE.MeshStandardMaterial({emissive:0xffd27a, color:0xfff0c2, roughness:0.2});
      const c=new THREE.Mesh(geo,mat); c.position.set(x,y,z); c.userData={coin:true, t:Math.random()*6.28};
      scene.add(c); collectibles.push(c);
    }
  }

  const camOff=new THREE.Vector3(0, 10, 18);
  let attackCD=0;

  function update(dt){
    // camera orientation
    player.yaw = yaw;

    // movement (from joystick/keys)
    const mx = (keys.d-keys.a) + joy.x*1.2;
    const mz = (keys.s-keys.w) + joy.y*1.2;
    let move=new THREE.Vector2(mx, mz);
    if(move.length()<0.1) move.set(0,0); else move.normalize();

    const cy=Math.cos(yaw), sy=Math.sin(yaw);
    const fw=new THREE.Vector3(sy,0,cy), rt=new THREE.Vector3(cy,0,-sy);
    const desired = rt.multiplyScalar(move.x).add(fw.multiplyScalar(-move.y));

    // speed & stamina
    const base=28, sprint=45;
    const spd = (keys.shift? sprint: base);
    if(keys.shift && player.stamina>0 && player.onGround){ player.stamina=Math.max(0, player.stamina - 22*dt); }
    if(!keys.shift && player.onGround) player.stamina=Math.min(100, player.stamina + 15*dt);

    player.vel.x = lerp(player.vel.x, desired.x*spd, 0.12);
    player.vel.z = lerp(player.vel.z, desired.z*spd, 0.12);

    // gravity / jump / glide
    const groundY=sampleHeight(player.pos.x, player.pos.z) + 4.0;
    player.onGround = player.pos.y <= groundY+0.05;
    const g=-40;
    if(player.onGround){
      player.pos.y=groundY; player.vel.y=0;
      if(keys.space){ player.vel.y=16; player.onGround=false; }
    }else{
      if(gliding && player.stamina>0){ player.vel.y=Math.max(player.vel.y,-5); player.stamina=Math.max(0, player.stamina-10*dt); }
      else player.vel.y += g*dt;
      if(!keys.shift) player.stamina=Math.min(100, player.stamina + 8*dt);
    }

    player.pos.addScaledVector(player.vel, dt);
    const half=terrainSize*0.48; player.pos.x=clamp(player.pos.x,-half,half); player.pos.z=clamp(player.pos.z,-half,half);

    // mesh & camera
    const yawFromVel = Math.atan2(-player.vel.z, player.vel.x) + Math.PI/2;
    if (desired.length()>0.01) playerMesh.rotation.y = lerp(playerMesh.rotation.y, yawFromVel, 0.3);
    playerMesh.position.copy(player.pos);
    const camRot = new THREE.Matrix4().makeRotationY(yaw);
    const off = camOff.clone().applyMatrix4(camRot);
    const camTarget = player.pos.clone().add(new THREE.Vector3(0,3,0));
    camera.position.copy(camTarget.clone().add(off)); camera.lookAt(camTarget);

    // attack
    attackCD=Math.max(0, attackCD-dt);
    if(keys.mouseDown && attackCD<=0){
      attackCD=0.35;
      enemies.forEach(e=>{ const d=player.pos.distanceTo(e.position); if(d<5){ e.userData.hp-=12; const dir=e.position.clone().sub(player.pos).normalize(); e.position.addScaledVector(dir,2.0); } });
    }

    // enemies AI
    enemies.forEach(e=>{
      if(e.userData.hp<=0){ scene.remove(e); e.geometry.dispose(); e.material.dispose(); e.userData.dead=true; }
      if(e.userData.dead) return;
      e.userData.t += dt;
      const to=player.pos.clone().sub(e.position); const dist=to.length();
      if(dist<50){
        to.normalize();
        e.position.addScaledVector(to, (dist<6? 0.0: 8.0)*dt);
        e.position.y = sampleHeight(e.position.x, e.position.z)+3 + Math.sin(e.userData.t*3)*0.2;
        if(dist<3.2){ player.hp = Math.max(0, player.hp - 10*dt); }
      }else{
        e.position.y = sampleHeight(e.position.x, e.position.z)+3 + Math.sin(e.userData.t*2)*0.3;
      }
    });

    // coins
    collectibles.forEach(c=>{
      c.userData.t += dt;
      c.position.y = sampleHeight(c.position.x, c.position.z)+2 + Math.sin(c.userData.t*2)*0.4;
      if(player.pos.distanceTo(c.position)<3){
        coinCount++; coinsEl.textContent='üí´ '+coinCount;
        scene.remove(c); c.geometry.dispose(); c.material.dispose(); c.userData.dead=true;
      }
    });

    // HUD
    document.getElementById('hp').style.width=(player.hp)+'%';
    document.getElementById('st').style.width=(player.stamina)+'%';
  }

  // Mouse camera
  let dragging=false,lastX=0,lastY=0;
  renderer.domElement.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY;});
  window.addEventListener('mousemove',e=>{
    if(!dragging) return; const dx=(e.clientX-lastX)/180, dy=(e.clientY-lastY)/180;
    yaw-=dx; pitch=clamp(pitch-dy,-1.2,0.6); lastX=e.clientX; lastY=e.clientY;
  });
  window.addEventListener('mouseup',()=>dragging=false);

  // Main loop
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    updateSky(); update(dt); renderer.render(scene,camera);
    requestAnimationFrame(loop);
  }

  // Menu start
  const startBtn=document.getElementById('start');
  const qualitySel=document.getElementById('quality');
  const seedSel=document.getElementById('seed');
  startBtn.addEventListener('click',()=>{
    const q=qualitySel.value, s=seedSel.value;
    makeTerrain(s,q);
    // place player
    player.pos.set(0, sampleHeight(0,0)+4, 0);
    player.vel.set(0,0,0); player.hp=100; player.stamina=100;
    // clear old
    enemies.slice().forEach(e=>{ if(e){ scene.remove(e);} }); enemies.length=0;
    collectibles.slice().forEach(c=>{ if(c){ scene.remove(c);} }); collectibles.length=0; coinCount=0; coinsEl.textContent='üí´ 0';
    // spawn enemies per biome regions
    for(let i=0;i<9;i++){
      const x=(Math.random()-0.5)*terrainSize*0.8, z=(Math.random()-0.5)*terrainSize*0.8;
      if(biomeAt(x,z)==='beach') continue;
      spawnEnemy(x,z);
    }
    spawnCoins(28);
    document.getElementById('menu').style.display='none';
    resize(); updateSky(); requestAnimationFrame(loop);
  });
})();</script>
</body>
</html>