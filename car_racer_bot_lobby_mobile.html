<!doctype html>
<html lang="bn">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Car Racer ‚Äî Bot + Lobby (Mobile)</title>
  <meta name="theme-color" content="#0b0b0b"/>
  <style>
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:#0b0b0b;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;overflow:hidden}
    #game{display:block;width:100vw;height:100vh;touch-action:none;background:#000}
    /* HUD */
    #hud{position:fixed;left:.75rem;bottom:8.5rem;background:#0008;padding:.5rem .6rem;border-radius:.6rem;border:1px solid #2d2d2d;
         pointer-events:none;font-size:.95rem;backdrop-filter:blur(2px);z-index:4}
    #hpwrap{position:fixed;right:.75rem;bottom:8.5rem;background:#0008;padding:.5rem .6rem;border-radius:.6rem;border:1px solid #2d2d2d;
         pointer-events:none;font-size:.95rem;backdrop-filter:blur(2px);z-index:4;min-width:180px}
    .hpbar{width:100%;height:12px;background:#333;border-radius:8px;overflow:hidden;margin-top:4px}
    .hpbar div{height:100%;background:#2ecc71}
    @media (min-width:900px){ #hud,#hpwrap{bottom:1rem} }
    /* Controls */
    #controls{position:fixed;left:0;right:0;bottom:.5rem;display:flex;justify-content:space-between;padding:0 .75rem;gap:1rem;pointer-events:none;z-index:4}
    #controls .col{display:flex;gap:.5rem}
    .ctrl{pointer-events:auto;min-width:4.2rem;min-height:4.2rem;border-radius:1rem;border:1px solid #2e2e2e;background:#1a1a1a;color:#fff;font-size:1.2rem;font-weight:700;box-shadow:0 .3rem .8rem #000a}
    .ctrl.big{min-width:6.2rem;min-height:6.2rem;font-size:1.3rem}
    .ctrl:active{transform:scale(.97)}
    /* Top bar */
    #topbar{position:fixed;left:0;right:0;top:0;display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:linear-gradient(#0009,#0000);z-index:5}
    #topbar button{pointer-events:auto;background:#222;border:1px solid #333;color:#fff;padding:.45rem .7rem;border-radius:.6rem;font-weight:700}
    #status{margin-left:auto;opacity:.9}
    /* Lobby */
    #lobby{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(1200px 800px at center,#0009,#000c);z-index:10}
    .panel{width:min(92vw,520px);background:linear-gradient(180deg,#121212,#0a0a0a);border:1px solid #2a2a2a;border-radius:14px;padding:18px;box-shadow:0 10px 40px #000c}
    .panel h1{margin:0 0 4px;font-size:1.4rem}
    .row{display:flex;gap:8px;margin:8px 0}
    .panel label{display:block;font-size:.9rem;margin-top:8px;margin-bottom:6px;opacity:.9}
    select,input[type=range]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #333;background:#181818;color:#fff}
    .btn{background:#222;border:1px solid #333;color:#fff;padding:10px 12px;border-radius:10px;font-weight:800;cursor:pointer}
    .btn.primary{background:#2b7cff;border-color:#3a86ff}
    .muted{opacity:.8;font-size:.9rem}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="topbar">
    <button id="btnReset">‚Ü∫ ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü</button>
    <button id="btnLobby">üè† ‡¶≤‡¶¨‡¶ø</button>
    <span id="status">Ready</span>
  </div>

  <div id="hud">
    <div><b>‡¶ó‡¶§‡¶ø:</b> <span id="speed">0</span> ‡¶ï‡¶ø‡¶Æ‡¶ø/‡¶ò‡¶®‡ßç‡¶ü‡¶æ</div>
    <div class="muted">‚üµ‚ü∂ ‡¶Æ‡ßã‡¶°‡¶º, ‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏/‡¶¨‡ßç‡¶∞‡ßá‡¶ï ‡¶¨‡ßã‡¶§‡¶æ‡¶Æ ‡¶®‡¶ø‡¶ö‡ßá</div>
  </div>
  <div id="hpwrap">
    <div><b>‡¶§‡ßÅ‡¶Æ‡¶ø</b></div>
    <div class="hpbar"><div id="hpMe" style="width:100%"></div></div>
    <div style="margin-top:6px"><b>‡¶¨‡¶ü</b></div>
    <div class="hpbar"><div id="hpBot" style="width:100%"></div></div>
  </div>

  <div id="controls">
    <div class="col">
      <button class="ctrl" data-act="left">‚üµ</button>
      <button class="ctrl" data-act="right">‚ü∂</button>
    </div>
    <div class="col">
      <button class="ctrl big" data-act="up">‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏</button>
      <button class="ctrl" data-act="down">‡¶¨‡ßç‡¶∞‡ßá‡¶ï</button>
    </div>
  </div>

  <!-- LOBBY -->
  <div id="lobby">
    <div class="panel">
      <h1>üöó Car Duel ‚Äî Single Player</h1>
      <div class="muted">‡¶¨‡¶ü (AI) ‡¶∏‡¶π ‡¶´‡ßç‡¶∞‡¶ø ‡¶°‡ßç‡¶∞‡¶æ‡¶á‡¶≠ ‡¶¨‡¶æ ‡¶¶‡ßÅ‡ßü‡ßá‡¶≤ ‡¶Æ‡ßã‡¶° ‡¶ñ‡ßá‡¶≤‡ßÅ‡¶®‡•§</div>

      <label>‡¶ó‡ßá‡¶Æ ‡¶Æ‡ßã‡¶°</label>
      <select id="mode">
        <option value="free">Free Drive (Bot Roaming)</option>
        <option value="duel">Duel vs Bot (Ram & Destroy)</option>
      </select>

      <label>‡¶¨‡¶ü ‡¶°‡¶ø‡¶´‡¶ø‡¶ï‡¶æ‡¶≤‡ßç‡¶ü‡¶ø</label>
      <select id="diff">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>

      <label>‡¶Æ‡ßç‡¶Ø‡¶æ‡¶™ ‡¶∏‡¶ø‡¶°</label>
      <input id="seed" placeholder="‡¶Ø‡ßá‡¶Æ‡¶®: tiger42" style="width:100%;padding:10px 12px;border-radius:10px;border:1px solid #333;background:#181818;color:#fff">

      <div class="row">
        <button id="start" class="btn primary" style="flex:2">‚ñ∂Ô∏è Start Game</button>
        <button id="shuffle" class="btn" style="flex:1">üé≤ Seed</button>
      </div>
      <div class="muted">‡¶ü‡¶ø‡¶™: Seed ‡¶¶‡¶ø‡¶≤‡ßá ‡¶¶‡ßÅ‡¶á‡¶ú‡¶®‡ßá‡¶∞ ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏‡ßá‡¶ì ‡¶è‡¶ï‡¶á ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶™ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá (‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡¶§‡ßá ‡¶∂‡ßá‡ßü‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)‡•§</div>
    </div>
  </div>

  <script>
  (()=>{
    'use strict';

    // ===== Config =====
    const TILE=64, MAP_W=120, MAP_H=120, ROAD_PROB=0.38;
    const PHYS={accel:240, brake:400, maxSpeedRoad:560, maxSpeedGrass:240, frictionRoad:120, frictionGrass:220, turnRate:2.2, turnSpeedRef:320};
    const START_HP=100;
    // Damage on collision
    const RAM_SPEED_THRESH=120, RAM_DAMAGE_K=0.04, RAM_COOLDOWN=350;

    // ===== State =====
    const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
    const statusEl=document.getElementById('status'), speedEl=document.getElementById('speed');
    const hpMeEl=document.getElementById('hpMe'), hpBotEl=document.getElementById('hpBot');
    const lobby=document.getElementById('lobby'), startBtn=document.getElementById('start');
    const seedInput=document.getElementById('seed'), shuffleBtn=document.getElementById('shuffle');
    const modeSel=document.getElementById('mode'), diffSel=document.getElementById('diff');
    const btnReset=document.getElementById('btnReset'), btnLobby=document.getElementById('btnLobby');

    const input={left:false,right:false,up:false,down:false};
    let map, rng, me, bot, waypoints=[], mode='free', duel=false, last=performance.now(), lastRam=0;

    // RNG from seed
    function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^=h>>>16)>>>0}}
    function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
    function makeRng(seed){const s=xmur3(seed||('s'+Math.random()))(); return mulberry32(s);}

    function rand(n){return Math.floor(rng()*n);}

    // Resize
    function resize(){
      const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
      canvas.width=Math.floor(innerWidth*dpr);
      canvas.height=Math.floor(innerHeight*dpr);
      canvas.style.width='100vw'; canvas.style.height='100vh';
    }
    addEventListener('resize', resize, {passive:true});

    // Map
    function genMap(){
      const grid=new Uint8Array(MAP_W*MAP_H);
      for(let y=2;y<MAP_H-2;y++){
        for(let x=2;x<MAP_W-2;x++){
          if(rng()<ROAD_PROB){ grid[y*MAP_W+x]=1; if(rng()<0.6) grid[y*MAP_W+x+1]=1; if(rng()<0.6) grid[y*MAP_W+x+MAP_W]=1; }
        }
      }
      for(let y=8;y<MAP_H;y+=12){ for(let x=2;x<MAP_W-2;x++) grid[y*MAP_W+x]=1; }
      for(let x=8;x<MAP_W;x+=12){ for(let y=2;y<MAP_H-2;y++) grid[y*MAP_W+x]=1; }
      for(let y=1;y<MAP_H-1;y++){
        for(let x=1;x<MAP_W-1;x++){
          const i=y*MAP_W+x; if(grid[i]!==0) continue;
          let near=false; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ if(grid[i+dy*MAP_W+dx]===1) near=true; }
          if(near && rng()<0.13) grid[i]=2;
        }
      }
      return {grid};
    }
    function tileAt(px,py){ const x=Math.floor(px/TILE), y=Math.floor(py/TILE); if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 0; return map.grid[y*MAP_W+x]; }
    function findStart(){
      const cx=Math.floor(MAP_W/2), cy=Math.floor(MAP_H/2);
      for(let r=0;r<Math.max(MAP_W,MAP_H);r++){
        for(let dy=-r;dy<=r;dy++){ for(let dx=-r;dx<=r;dx++){
          const x=cx+dx, y=cy+dy; if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
          if(map.grid[y*MAP_W+x]===1){ return {x:x*TILE+TILE/2, y:y*TILE+TILE/2}; }
        }}
      }
      return {x:cx*TILE, y:cy*TILE};
    }

    // Waypoints on roads for bot roaming
    function buildWaypoints(count=30){
      const list=[]; let tries=0;
      while(list.length<count && tries++<count*200){
        const x=2+rand(MAP_W-4), y=2+rand(MAP_H-4);
        if (map.grid[y*MAP_W+x]===1){
          // keep some spacing
          let ok=true;
          for(const p of list){ const dx=p.x-x, dy=p.y-y; if(dx*dx+dy*dy<40) {ok=false;break;} }
          if(ok) list.push({x:(x+0.5)*TILE, y:(y+0.5)*TILE});
        }
      }
      return list;
    }

    // Cars
    function makeCar(offX=0, color='#cc2222'){
      const s=findStart();
      return { x:s.x+offX, y:s.y, angle:0, speed:0, w:44, h:76, color, hp:START_HP };
    }

    // Update physics (common)
    function updateCar(c, inputLeft, inputRight, inputUp, inputDown, dt, onRoadBoost=1){
      const onRoad=[1,3].includes(tileAt(c.x,c.y));
      const max = onRoad ? PHYS.maxSpeedRoad*onRoadBoost : PHYS.maxSpeedGrass;
      const fr  = onRoad ? PHYS.frictionRoad : PHYS.frictionGrass;

      if (inputUp) c.speed += PHYS.accel*dt;
      if (inputDown) c.speed -= PHYS.brake*dt;
      if (!inputUp && !inputDown){
        if (c.speed>0) c.speed=Math.max(0, c.speed-fr*dt);
        else if (c.speed<0) c.speed=Math.min(0, c.speed+fr*dt);
      }
      c.speed = Math.max(-max*0.45, Math.min(max, c.speed));

      const turn = (inputLeft?-1:0) + (inputRight?1:0);
      const sf = Math.max(0, Math.min(1, Math.abs(c.speed)/PHYS.turnSpeedRef));
      c.angle += turn * PHYS.turnRate * sf * dt;

      const nx = c.x + Math.cos(c.angle)*c.speed*dt;
      const ny = c.y + Math.sin(c.angle)*c.speed*dt;
      if (tileAt(nx,ny)===2) { c.speed *= -0.3; } else { c.x=nx; c.y=ny; }
    }

    // Bot AI
    let botTargetIdx=0, botTarget=null;
    function pickNextWaypoint(fromPos){
      if (waypoints.length===0) waypoints = buildWaypoints(30);
      botTargetIdx = (botTargetIdx + 1) % waypoints.length;
      botTarget = waypoints[botTargetIdx];
      // ensure not too close
      if (dist2(fromPos, botTarget) < 8000) pickNextWaypoint(fromPos);
    }
    function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
    function steerTowards(c, tx, ty, turnScale, dt){
      const desired = Math.atan2(ty - c.y, tx - c.x);
      let d = ((desired - c.angle + Math.PI) % (Math.PI*2)) - Math.PI;
      const turn = Math.max(-1, Math.min(1, d / (Math.PI/3))); // soft clamp
      const sf = Math.max(0, Math.min(1, Math.abs(c.speed)/PHYS.turnSpeedRef));
      c.angle += turn * PHYS.turnRate * sf * turnScale * dt;
    }
    function botUpdate(dt){
      if (!botTarget) pickNextWaypoint(bot);
      const difficulty = diffSel.value;
      let onRoadBoost = 1;
      let targetSpeed = 300;
      if (mode==='duel'){
        // chase player
        botTarget = {x: me.x, y: me.y};
        targetSpeed = (difficulty==='hard'? PHYS.maxSpeedRoad*0.95 : difficulty==='normal'? 420 : 360);
        onRoadBoost = (difficulty==='hard'? 1.05 : 1.0);
      } else {
        // roam
        if (dist2(bot, botTarget) < 9000) pickNextWaypoint(bot);
        targetSpeed = (difficulty==='hard'? 420 : difficulty==='normal'? 360 : 300);
        onRoadBoost = 1.0;
      }

      // steering and speed choice
      steerTowards(bot, botTarget.x, botTarget.y, (difficulty==='easy'? 0.8 : 1.0), dt);
      const wantUp   = (bot.speed < targetSpeed);
      const wantDown = false;

      // slight collision avoidance: lookahead
      const lookX = bot.x + Math.cos(bot.angle)*50;
      const lookY = bot.y + Math.sin(bot.angle)*50;
      if (tileAt(lookX,lookY)===2){
        // rotate away
        bot.angle += (rng()<0.5? -1:1) * 1.2 * dt;
      }

      updateCar(bot, false,false, wantUp, wantDown, dt, onRoadBoost);
    }

    // Collision + damage (player vs bot)
    function handleCollision(){
      const rad = (me.h*0.5 + bot.h*0.5)*0.55;
      const dx = me.x - bot.x, dy = me.y - bot.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < rad*rad){
        const d = Math.max(8, Math.sqrt(d2));
        const nx = dx/d, ny = dy/d;
        // push cars apart
        me.x += nx*2; me.y += ny*2;
        bot.x -= nx*2; bot.y -= ny*2;
        // damage
        const now=performance.now();
        const rel = Math.abs(me.speed - bot.speed);
        if (now-lastRam>RAM_COOLDOWN && rel>RAM_SPEED_THRESH && duel){
          lastRam = now;
          const dmg = (rel - RAM_SPEED_THRESH) * RAM_DAMAGE_K;
          me.hp = Math.max(0, me.hp - dmg*0.6);
          bot.hp = Math.max(0, bot.hp - dmg);
          statusEl.textContent = 'üí• Impact!';
        }
      }
    }

    // Draw
    function draw(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
      const W=canvas.width, H=canvas.height;

      // background
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,W,H);

      const cx=me.x, cy=me.y;
      const ox = Math.floor(W/2 - cx*dpr);
      const oy = Math.floor(H/2 - cy*dpr);
      ctx.setTransform(dpr,0,0,dpr, ox, oy);

      // visible tiles
      const viewW = W/dpr, viewH = H/dpr;
      const x0=Math.max(0,Math.floor((cx - viewW/2)/TILE)-2);
      const y0=Math.max(0,Math.floor((cy - viewH/2)/TILE)-2);
      const x1=Math.min(MAP_W-1,Math.floor((cx + viewW/2)/TILE)+2);
      const y1=Math.min(MAP_H-1,Math.floor((cy + viewH/2)/TILE)+2);

      for(let y=y0;y<=y1;y++){
        for(let x=x0;x<=x1;x++){
          const t=map.grid[y*MAP_W+x], px=x*TILE, py=y*TILE;
          if(t===1){ ctx.fillStyle='#4f4f4f'; ctx.fillRect(px,py,TILE,TILE); ctx.strokeStyle='#cfcfcf33'; ctx.lineWidth=2; ctx.strokeRect(px+2,py+2,TILE-4,TILE-4); }
          else if(t===2){ ctx.fillStyle='#2b2b2b'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle='#3d3d3d'; ctx.fillRect(px+8,py+8,TILE-16,TILE-16); }
          else { ctx.fillStyle='#1f6d2a'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle='#2a8736'; ctx.globalAlpha = 0.25; for(let i=0;i<3;i++){ ctx.fillRect(px+rng()*TILE, py+rng()*TILE, 3,3);} ctx.globalAlpha = 1; }
        }
      }

      // draw bot
      if (bot){
        ctx.save();
        ctx.translate(bot.x, bot.y);
        ctx.rotate(bot.angle);
        ctx.fillStyle = '#2299cc';
        roundRect(ctx, -bot.w/2, -bot.h/2, bot.w, bot.h, 10);
        ctx.fill();
        ctx.restore();
      }

      // draw me (on top)
      ctx.save();
      ctx.translate(me.x, me.y);
      ctx.rotate(me.angle);
      ctx.fillStyle = me.color || '#cc2222';
      roundRect(ctx, -me.w/2, -me.h/2, me.w, me.h, 10);
      ctx.fill();
      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

    // Loop
    function loop(t){
      const dt=Math.min(0.033,(t-last)/1000); last=t;
      // Player
      const onRoad=[1,3].includes(tileAt(me.x,me.y));
      updateCar(me, input.left, input.right, input.up, input.down, dt, 1);
      // Bot
      if (bot) botUpdate(dt);
      // Collision / duel damage
      if (bot) handleCollision();
      // Draw
      draw();
      // HUD
      speedEl.textContent = Math.round(Math.abs(me.speed)*3.6/100);
      hpMeEl.style.width = (me.hp) + '%';
      hpBotEl.style.width = (bot? bot.hp : 100) + '%';
      // Win/Lose text
      if (duel){
        if (me.hp<=0 && bot.hp<=0) statusEl.textContent='‡¶°‡ßç‡¶∞';
        else if (me.hp<=0) statusEl.textContent='‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶π‡ßá‡¶∞‡ßá‡¶õ‡ßã üòÖ';
        else if (bot.hp<=0) statusEl.textContent='‡¶§‡ßÅ‡¶Æ‡¶ø Winner! üéâ';
      }
      requestAnimationFrame(loop);
    }

    // Input
    document.querySelectorAll('.ctrl').forEach(btn=>{
      const act=btn.dataset.act;
      const on = ()=> input[act]=true, off=()=> input[act]=false;
      btn.addEventListener('touchstart',e=>{e.preventDefault();on();},{passive:false});
      btn.addEventListener('touchend',e=>{e.preventDefault();off();},{passive:false});
      btn.addEventListener('touchcancel',e=>{e.preventDefault();off();},{passive:false});
    });
    addEventListener('keydown',e=>{
      if(['ArrowLeft','a','A'].includes(e.key)) input.left=true;
      if(['ArrowRight','d','D'].includes(e.key)) input.right=true;
      if(['ArrowUp','w','W'].includes(e.key)) input.up=true;
      if(['ArrowDown','s','S'].includes(e.key)) input.down=true;
      if(e.key==='Escape') lobby.style.display='flex';
    });
    addEventListener('keyup',e=>{
      if(['ArrowLeft','a','A'].includes(e.key)) input.left=false;
      if(['ArrowRight','d','D'].includes(e.key)) input.right=false;
      if(['ArrowUp','w','W'].includes(e.key)) input.up=false;
      if(['ArrowDown','s','S'].includes(e.key)) input.down=false;
    });

    // Buttons
    btnReset.onclick=()=>{ setupWorld(seedInput.value||'solo'); statusEl.textContent='‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®'; };
    btnLobby.onclick=()=>{ lobby.style.display='flex'; };

    // Setup world
    function setupWorld(seed){
      rng = makeRng(seed||'solo');
      map = genMap();
      waypoints = buildWaypoints(30);
      me = makeCar(-TILE*2, '#cc2222');
      bot = makeCar(TILE*2, '#2299cc');
      botTarget = null; // new
      me.hp = START_HP; bot.hp = START_HP; lastRam=0;
    }

    // Lobby actions
    startBtn.onclick=()=>{
      mode = modeSel.value;
      duel = (mode==='duel');
      setupWorld(seedInput.value || 'solo');
      lobby.style.display='none';
      statusEl.textContent = (duel? 'Duel vs Bot' : 'Free Drive (Bot roaming)');
      requestAnimationFrame(loop);
    };
    shuffleBtn.onclick=()=>{
      seedInput.value = 'seed' + Math.floor(Math.random()*100000).toString(36);
    };

    // Init (show lobby)
    resize();
    seedInput.value = 'solo';
    statusEl.textContent='In Lobby';
  })();
  </script>
</body>
</html>
